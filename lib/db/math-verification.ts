// lib/utils/math-verification.ts

interface MathQuestion {
  text: string;
  options: string[];
  correctAnswer: string;
  difficulty: number;
  subject: string;
}

class MathVerificationService {
  
  /**
   * Verifies and corrects mathematical questions generated by AI
   */
  static verifyMathQuestion(question: MathQuestion): {
    isValid: boolean;
    correctedQuestion?: MathQuestion;
    errors: string[];
  } {
    const errors: string[] = [];
    
    if (question.subject !== 'math') {
      return { isValid: true, errors: [] }; // Skip non-math questions
    }

    try {
      // Extract mathematical expression from question text
      const mathExpression = this.extractMathExpression(question.text);
      
      if (!mathExpression) {
        // Not a computational math question, skip verification
        return { isValid: true, errors: [] };
      }

      // Calculate correct answer
      const computedAnswer = this.evaluateMathExpression(mathExpression);
      
      if (computedAnswer === null) {
        errors.push('Could not compute mathematical expression');
        return { isValid: false, errors };
      }

      // Check if provided correct answer matches computation
      const providedAnswer = this.parseNumericAnswer(question.correctAnswer);
      
      if (Math.abs(providedAnswer - computedAnswer) > 0.01) {
        errors.push(`AI provided wrong answer: ${providedAnswer}, correct is: ${computedAnswer}`);
        
        // Generate corrected question
        const correctedQuestion = this.generateCorrectedQuestion(
          mathExpression, 
          computedAnswer, 
          question.difficulty
        );
        
        return { 
          isValid: false, 
          correctedQuestion,
          errors 
        };
      }

      return { isValid: true, errors: [] };

    } catch (error) {
      errors.push(`Verification failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return { isValid: false, errors };
    }
  }

  /**
   * Extract mathematical expressions from question text
   */
  private static extractMathExpression(text: string): string | null {
    // Division patterns
    const divisionMatch = text.match(/(\d+)\s*√∑\s*(\d+)/);
    if (divisionMatch) {
      return `${divisionMatch[1]} / ${divisionMatch[2]}`;
    }

    // Multiplication patterns
    const multiplyMatch = text.match(/(\d+)\s*[√ó*]\s*(\d+)/);
    if (multiplyMatch) {
      return `${multiplyMatch[1]} * ${multiplyMatch[2]}`;
    }

    // Fraction to decimal patterns
    const fractionMatch = text.match(/(\d+)\/(\d+)\s*to\s*decimal/i);
    if (fractionMatch) {
      return `${fractionMatch[1]} / ${fractionMatch[2]}`;
    }

    // Percentage patterns
    const percentMatch = text.match(/(\d+)%\s*of\s*(\d+)/);
    if (percentMatch) {
      return `${percentMatch[1]} / 100 * ${percentMatch[2]}`;
    }

    // Basic addition/subtraction
    const basicMatch = text.match(/(\d+)\s*([+\-])\s*(\d+)/);
    if (basicMatch) {
      return `${basicMatch[1]} ${basicMatch[2]} ${basicMatch[3]}`;
    }

    return null;
  }

  /**
   * Safely evaluate mathematical expressions
   */
  private static evaluateMathExpression(expression: string): number | null {
    try {
      // Clean and validate expression
      const cleanExpr = expression.replace(/[^0-9+\-*/.() ]/g, '');
      
      // Basic safety check - only allow numbers and operators
      if (!/^[\d+\-*/.() ]+$/.test(cleanExpr)) {
        return null;
      }

      // Use Function constructor for safer evaluation than eval
      const result = Function(`"use strict"; return (${cleanExpr})`)();
      
      return typeof result === 'number' && isFinite(result) ? 
        Math.round(result * 100) / 100 : null;
        
    } catch {
      return null;
    }
  }

  /**
   * Parse numeric answer from string (handles various formats)
   */
  private static parseNumericAnswer(answer: string): number {
    // Extract number from answer choice format "A) 4.25" -> "4.25"
    const numMatch = answer.match(/([\d.]+)/);
    return numMatch ? parseFloat(numMatch[1]) : 0;
  }

  /**
   * Generate a corrected question with proper answers
   */
  private static generateCorrectedQuestion(
    expression: string, 
    correctAnswer: number, 
    difficulty: number
  ): MathQuestion {
    
    const questionText = this.generateQuestionText(expression, correctAnswer);
    const options = this.generateAnswerOptions(correctAnswer, difficulty);
    
    return {
      text: questionText,
      options: options.map((opt, idx) => `${String.fromCharCode(65 + idx)}) ${opt}`),
      correctAnswer: `A) ${correctAnswer}`, // Correct answer always first, will be shuffled later
      difficulty,
      subject: 'math'
    };
  }

  /**
   * Generate proper question text from expression
   */
  private static generateQuestionText(expression: string, answer: number): string {
    if (expression.includes(' / ') && expression.includes('.')) {
      // Fraction to decimal
      const parts = expression.split(' / ');
      return `Convert ${parts[0]}/${parts[1]} to a decimal.`;
    }
    
    if (expression.includes(' * ')) {
      const parts = expression.split(' * ');
      return `What is ${parts[0]} √ó ${parts[1]}?`;
    }
    
    if (expression.includes(' / ')) {
      const parts = expression.split(' / ');
      return `What is ${parts[0]} √∑ ${parts[1]}?`;
    }
    
    return `Calculate: ${expression.replace(/\*/g, '√ó').replace(/\//g, '√∑')}`;
  }

  /**
   * Generate plausible wrong answers based on difficulty
   */
  private static generateAnswerOptions(correct: number, difficulty: number): number[] {
    const options = [correct];
    
    // Generate 3 plausible distractors
    const errorMargin = difficulty <= 3 ? 1 : difficulty <= 6 ? 2 : 3;
    
    // Common error patterns
    options.push(correct + errorMargin);      // Off by addition
    options.push(correct - errorMargin);      // Off by subtraction  
    options.push(Math.round(correct * 1.1));  // 10% calculation error
    
    // Ensure all options are positive and distinct
    return options
      .map(opt => Math.max(0.01, opt))
      .filter((opt, idx, arr) => arr.indexOf(opt) === idx)
      .slice(0, 4)
      .sort(() => Math.random() - 0.5); // Shuffle
  }

  /**
   * Batch verify multiple questions
   */
  static verifyQuestionBatch(questions: MathQuestion[]): {
    validQuestions: MathQuestion[];
    correctedQuestions: MathQuestion[];
    invalidCount: number;
  } {
    const validQuestions: MathQuestion[] = [];
    const correctedQuestions: MathQuestion[] = [];
    let invalidCount = 0;

    questions.forEach(question => {
      const verification = this.verifyMathQuestion(question);
      
      if (verification.isValid) {
        validQuestions.push(question);
      } else if (verification.correctedQuestion) {
        correctedQuestions.push(verification.correctedQuestion);
        console.log(`üìê Math corrected: ${verification.errors[0]}`);
      } else {
        invalidCount++;
        console.log(`‚ùå Math invalid: ${verification.errors[0]}`);
      }
    });

    return { validQuestions, correctedQuestions, invalidCount };
  }
}

export default MathVerificationService;